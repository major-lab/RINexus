package ca.iric.major.common;

import java.util.List;
import java.util.ArrayList;

/**
 * Class for an RNA sequence based on a String implementation
 *
 * @version %I% %G%
 * @author Francois Major
 * @copyright 2021 - MajorLab, IRIC, Universite de Montreal
 * @license MIT
*/

public class StringSequence implements Sequence {

    // Sequence utilities
    public static char[] nucleotides = { 'A', 'C', 'G', 'U' };
    public static int alphabetLength = 4;

    // GU base pairs
    public final static String guBps = "GUG";

    // Canonical base pairs
    public final static String canonicalBps = "AUA CGC";

    // Canonical + GU base pairs
    public final static String canonicalGUBps = "AUA GCGUG";

    public static Character complement( Character c ) {
	switch( c ) {
	case 'A': return 'U';
	case 'C': return 'G';
	case 'U': return 'A';
	case 'G': return 'C';
	default: return ' ';
	}
    }

    public static int countBPs( String sense, String antisense ) { // assume sense and antisense same size
	String antiantisense = Utils.reverse( antisense ); // reverse the antisense, as it is given 5'->3'
	int numBPs = 0;
	for( int i = 0; i < sense.length(); i++ )
	    if( canonicalGUBps.contains( Character.toString( sense.charAt( i ) ) + Character.toString( antiantisense.charAt( i ) ) ) ) numBPs++;
	return numBPs;
    }

    private String sequence = "";

    public StringSequence( String sequence ) { this.sequence = sequence; }
    
    // getters from Sequence interface
    public String getSequence() { return this.sequence; }
    
    public String getSequence( int start, int end ) {
	// substring [start..end[
	if( !( inSequence( start, this ) && inSequence( end - 1, this ) ) ) notInSequence( start, end, this );
	return this.sequence.substring( start, end );
    }
    
    public char getNucleotide( int position ) {
	if( !inSequence( position, this ) ) notInSequence( position, this );
	return this.sequence.charAt( position );
    }
    
    public int length() { return this.sequence.length(); }
    public void setSequence( String sequence ) { this.sequence = sequence; }

    public String toString() { return this.sequence; }

    // Utilities
    
    public static boolean inSequence( int position, Sequence sequence ) {
	return position >= 0 && position < sequence.length();
    }

    public static boolean inSequence( int start, int end, Sequence sequence ) {
	return start <= end && start >= 0 && end < sequence.length();
    }

    public static void notInSequence( int position, Sequence sequence ) throws IllegalArgumentException {
	throw new IllegalArgumentException( position + " is not in sequence range [0.." + (sequence.length() - 1) + "]" );
    }

    public static void notInSequence( int start, int end, Sequence sequence ) throws IllegalArgumentException {
	throw new IllegalArgumentException( "[" + start + ".." + end + "[ not in sequence range [0.." + (sequence.length() - 1) + "]" );
    }

    public static String toFasta( Sequence sequence ) {
	String fastaSequence = "";
	int i = 0;
	for( i = 0; i < sequence.length(); i = i + 60 )
	    fastaSequence += sequence.getSequence( i, Math.min( i+60, sequence.length() ) ) + "\n";
	return fastaSequence.substring( 0, fastaSequence.length() - 1 );  // remove the last '\n'
    }

    public static boolean isRNA( String sequence ) {
        // Iterate over each character in the sequence
        for( int i = 0; i < sequence.length(); i++ ) {
            char c = sequence.charAt( i );
            if( c != 'A' && c != 'C' && c != 'G' && c != 'U' ) {
                return false; // Found an invalid character
            }
        }
        return true; // No invalid characters found
    }

    public static String reverseComplement( String strand ) {
	String antiStrand = "";
	for( int k = 0; k < strand.length(); k++ )
	    antiStrand += complement( strand.charAt( k ) );
	return Utils.reverse( antiStrand );
    }

    // KMer utilities

    public static void generateKMers( int k, List<String> exclusions, List<String> kmers ) {
	generateKMersRec( nucleotides, "", alphabetLength, k, exclusions, kmers );
    }

    public static void generateKMers( int k, List<String> kmers ) {
	generateKMersRec( nucleotides, "", alphabetLength, k, new ArrayList<String>(), kmers );
    }

    private static boolean contains( String s, List<String> substrings ) {
	// check if contains one of the substrings
	for( String sub : substrings )
	    if( s.contains( sub ) ) return true;
	return false;
    }

    private static void generateKMersRec( char[] set, String prefix, int n, int k, List<String> exclusions, List<String> kmers ) {
	// Base case: k is  => add prefix to list
	if( k == 0 ) {
	    if( !contains( prefix, exclusions ) ) // if the prefix does not contain one of the exclusions
		kmers.add( prefix ); // add it to the list
	    return;
	}
	// Add each char from set and
	//     recursively call for k-1
	for( int i = 0; i < n; ++i ) {
	    // Add current char
	    String newPrefix = prefix + set[i];
	    generateKMersRec( set, newPrefix, n, k-1, exclusions, kmers ); // Decrease k and call recursively
	}
    }

}
