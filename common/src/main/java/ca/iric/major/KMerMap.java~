package ca.iric.major.mirbooking;

/**
 * KMerMap stores supplementary and seed prefix positions in a set of transcripts
 * The position of a kmer is the position of its first character.
 * The kmers' positions are restricted to the region received as an argument in the constructor
 * The KMerMap stores the positions of all kmers, k = seedPrefixL for seeds and suppPrefixL for supp
 *
 * @version 2.0
 * @author Francois Major
 * @copyright 1.0 2021 - MajorLab, IRIC, Universite de Montreal
 * @copyright 2.0 2024 - MajorLab, IRIC, Universite de Montreal
 * @license MIT
*/

import ca.iric.major.common.*;

import java.lang.IllegalArgumentException;

import java.util.Set;
import java.util.Map;
import java.util.HashMap;
import java.util.List;
import java.util.ArrayList;
import java.util.Iterator;

import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;

/**
 * KMerMap for holding kmer positions in a list of Transcripts
 *   split in two sets, one for the seeds and one for the supp
 *   (they might not have the same length)
 *
 * @version 1.0
 * @author Francois Major
 * @copyright 2021 - MajorLab, IRIC, Universite de Montreal
 * @license MIT
*/

public class KMerMap {

    // Method to encode a k-mer string into an integer
    public static int kmerToInt( String kmer ) {
        int index = 0;
        for( int i = 0; i < kmer.length(); i++ ) {
            char nucleotide = kmer.charAt(i);
            int value = 0;
            switch( nucleotide ) {
	    case 'A': value = 0; break;
	    case 'C': value = 1; break;
	    case 'G': value = 2; break;
	    case 'U': value = 3; break;
	    default: throw new IllegalArgumentException("Invalid nucleotide: " + nucleotide);
            }
            index = ( index << 2 ) | value; // Shift left by 2 bits (base 4) and add the value
        }
        return index;
    }

    // Method to decode an integer back into a k-mer string
    public static String intToKmer( int index, int k ) {
        StringBuilder kmer = new StringBuilder();
        for( int i = 0; i < k; i++ ) {
            int value = index & 3; // Get the last 2 bits (base 4)
            char nucleotide = 'A'; // Default to 'A'
            switch (value) {
	    case 0: nucleotide = 'A'; break;
	    case 1: nucleotide = 'C'; break;
	    case 2: nucleotide = 'G'; break;
	    case 3: nucleotide = 'U'; break;
            }
            kmer.insert(0, nucleotide); // Insert at the beginning
            index = index >> 2; // Shift right by 2 bits
        }
        return kmer.toString();
    }

    public static List<Integer> findKmerPositions( CodingTranscript t, String kmer, int region ) {
        List<Integer> positions = new ArrayList<>();
	String sequence = t.getStringSequence();
        int index = sequence.indexOf( kmer ); // find first instance
        while( index >= 0 ) {
	    if( t.validateRegion( region, index, index + kmer.length() -1 ) )
		positions.add( index );
            index = sequence.indexOf( kmer, index + 1 ); // continue searching from the next character
        }
        return positions;
    }

    public List<String> getExclusiveCommonSupp( Set<ProteinCodingTranscript> targetSubset, Set<ProteinCodingTranscript> excludedSubset ) {
	List<String> kmerList = new ArrayList<>();
	// search supp prefixes
	for( int i = 0; i < Math.pow( 4, this.suppPrefixL); i++ ) { // for each supp prefixes
	    String kmer = intToKmer( i, this.suppPrefixL ); // kmer String
	    if( isInAllSupp( i, targetSubset ) && isNotIn( kmer, excludedSubset ) )
		kmerList.add( kmer );
	}
	return kmerList;
    }

    public List<String> getExclusiveCommonSupp( Set<ProteinCodingTranscript> targetSubset ) {
	List<String> kmerList = new ArrayList<>();
	// search supp prefixes
	for( int i = 0; i < Math.pow( 4, this.suppPrefixL); i++ ) { // for each supp prefixes
	    String kmer = intToKmer( i, this.suppPrefixL ); // kmer String
	    if( isInAllSupp( i, targetSubset ) )
		kmerList.add( kmer );
	}
	return kmerList;
    }

    public List<String> getExclusiveCommonSeed( Set<ProteinCodingTranscript> targetSubset ) {
	List<String> kmerList = new ArrayList<>();
	// search seed prefixes
	for( int i = 0; i < Math.pow( 4, this.seedPrefixL ); i++ ) { // for each seed prefixes
	    String kmer = intToKmer( i, this.seedPrefixL ); // kmer String
	    if( isInAllSeed( i, targetSubset ) )
		kmerList.add( kmer );
	}
	return kmerList;
    }

    public List<String> getExclusiveCommonSeed( Set<ProteinCodingTranscript> targetSubset, Set<ProteinCodingTranscript> excludedSubset ) {
	List<String> kmerList = new ArrayList<>();
	// search seed prefixes
	for( int i = 0; i < Math.pow( 4, this.seedPrefixL ); i++ ) { // for each seed prefixes
	    String kmer = intToKmer( i, this.seedPrefixL ); // kmer String
	    if( isInAllSeed( i, targetSubset ) && isNotIn( kmer, excludedSubset ) )
		kmerList.add( kmer );
	}
	return kmerList;
    }

    protected List<ProteinCodingTranscript> transcripts;               // transcript set
    protected Map<ProteinCodingTranscript,Integer> transcriptsIndices; // transcript indices for the positions' lists
    protected int region;                                              // region of the transcript considered
    protected List<String> exclusions;                                 // string not to be found in the prefixes
    private List<Integer>[][] positionsSupp;                           // positions of the suppc for all transcripts, first dimension kmer, second dimension transcript index
    private List<Integer>[][] positionsSeed;                           // positions of the seedc for all transcripts, first dimension kmer, second dimension transcript index
    private int seedPrefixL;                                           // length of the seed prefix
    private int suppPrefixL;                                           // length of the supp prefix
    
    // Constructor
    public KMerMap( List<ProteinCodingTranscript> transcripts, int region, List<String> exclusions, int seedPrefixL, int suppPrefixL ) {

	//System.out.println( "KMerMap for transcripts: " + transcripts );
	// initialize the attributes
	this.transcripts = transcripts;
	this.region = region;
	this.exclusions = exclusions;
	this.seedPrefixL = seedPrefixL;
	this.suppPrefixL = suppPrefixL;
	this.transcriptsIndices = new HashMap<>();

	// initialize the arrays of positions
	int suppDepth = (int)Math.pow( 4, this.suppPrefixL );
	int seedDepth = (int)Math.pow( 4, this.seedPrefixL );
	this.positionsSupp = new ArrayList[suppDepth][this.transcripts.size()];
	this.positionsSeed = new ArrayList[seedDepth][this.transcripts.size()];
	for( int i = 0; i < suppDepth; i++ )
	    for( int j = 0; j < this.transcripts.size(); j++ )
		positionsSupp[i][j] = new ArrayList<>();
	for( int i = 0; i < seedDepth; i++ )
	    for( int j = 0; j < this.transcripts.size(); j++ )
		positionsSeed[i][j] = new ArrayList<>();

	// initialize transcript indices
	for( int i = 0; i < this.transcripts.size(); i++ ) { // iterate the transcripts
	    this.transcriptsIndices.put( this.transcripts.get( i ), i );
	    //System.out.println( this.transcripts.get( i ) + " is indexed at " + i );
	}

	// make seed array
	for( int i = 0; i < seedDepth; i++ ) { // for each seed prefix
	    String kmer = intToKmer( i, this.seedPrefixL ); // kmer String
	    for( int j = 0; j < this.transcripts.size(); j++ ) // iterate the transcripts
		if( !containsAnySubstring( kmer, exclusions ) )
		    this.positionsSeed[i][j] = findKmerPositions( this.transcripts.get( j ), kmer, region );
	}

	// make supp array
	for( int i = 0; i < suppDepth; i++ ) { // for each supp prefix
	    String kmer = intToKmer( i, this.suppPrefixL ); // kmer String
		for( int j = 0; j < this.transcripts.size(); j++ ) { // iterate the transcripts
		    if( !containsAnySubstring( kmer, exclusions ) )
			this.positionsSupp[i][j] = findKmerPositions( this.transcripts.get( j ), kmer, region );
		}
	}
    }

    public int getNumberOfTranscripts() { return this.transcripts.size(); }
    public int getSeedPrefixL() { return this.seedPrefixL; }
    public int getSuppPrefixL() { return this.suppPrefixL; }
    public List<ProteinCodingTranscript> getTranscripts() { return this.transcripts; }
    // get the positions of the seeds in a given transcript
    public List<Integer> getSeedPositions( String kmer, ProteinCodingTranscript pct ) {
	return this.positionsSeed[kmerToInt( kmer )][this.transcriptsIndices.get( pct )];
    }
    // get the positions of the supp in a given transcript
    public List<Integer> getSuppPositions( String kmer, ProteinCodingTranscript pct ) {
	return this.positionsSupp[kmerToInt( kmer )][this.transcriptsIndices.get( pct )];
    }
    // get the positions of a seed's kmer in a transcript by its index
    public List<Integer> getSeedPositions( String kmer, int pct ) { return this.positionsSeed[kmerToInt( kmer )][pct]; }
    // get the positions of a supp's kmer in a transcript by its index
    public List<Integer> getSuppPositions( String kmer, int pct ) { return this.positionsSupp[kmerToInt( kmer )][pct]; }
    public int getRegion() { return this.region; }
    public List<String> getExclusions() { return this.exclusions; }
    // get transcript at index i
    public ProteinCodingTranscript getTarget( int i ) { return this.transcripts.get( i ); }

    // Utilities

    private static boolean containsAnySubstring( String kmer, List<String> substrings ) {
        for( String substring : substrings ) {
            if( kmer.contains( substring ) ) {
                return true; // Return true as soon as a match is found
            }
        }
        return false; // Return false if no matches are found
    }

    private static boolean isNotIn( String kmer, Set<ProteinCodingTranscript> excluded ) {
	for( ProteinCodingTranscript t : excluded )
	    if( t.getTargetableSequence().contains( kmer ) ) return false;
	return true;
    }

    private boolean isInAllSupp( int kmerIndex, Set<ProteinCodingTranscript> transcripts ) {
	for( ProteinCodingTranscript t : transcripts ) if( this.positionsSupp[kmerIndex][this.transcriptsIndices.get( t )].size() == 0 ) return false;
	return true;
    }

    private boolean isInAllSeed( int kmerIndex, Set<ProteinCodingTranscript> transcripts ) {
	//System.out.println( "transcripts in isInAllSeed: " + transcripts );
	for( ProteinCodingTranscript t : transcripts ) {
	    //System.out.println( "this.positionsSeed[" + kmerIndex + "][" + this.transcriptsIndices.get( t ) + "].size() = " +  this.positionsSeed[kmerIndex][this.transcriptsIndices.get( t )] );
	    if( this.positionsSeed[kmerIndex][this.transcriptsIndices.get( t )].size() == 0 ) return false;
	}
	return true;
    }

    public String toString() {
	String result = "";
	// visualize supp map
	for( int i = 0; i < Math.pow( 4, this.suppPrefixL ); i++ ) { // for each supp prefix
	    String kmer = intToKmer( i, this.suppPrefixL ); // kmer String
	    for( int j = 0; j < this.transcripts.size(); j++ ) // iterate the transcripts
		if( !this.positionsSupp[i][j].isEmpty() ) result += kmer + " in " + this.transcripts.get( j ).getName() + ": " + this.positionsSupp[i][j] + "\n";
	}
	// visualize seed map
	for( int i = 0; i < Math.pow( 4, this.seedPrefixL ); i++ ) { // for each seed prefix
	    String kmer = intToKmer( i, this.seedPrefixL ); // kmer String
	    for( int j = 0; j < this.transcripts.size(); j++ ) // iterate the transcripts
		if( !this.positionsSeed[i][j].isEmpty() ) result += kmer + " in " + this.transcripts.get( j ).getName() + ": " + this.positionsSeed[i][j] + "\n";
	}
	return result;
    }
}
